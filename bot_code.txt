

# ===== .\bot.py =====

Ôªø# bot.py
import asyncio
import logging
from aiogram import Bot, Dispatcher
from aiogram.fsm.storage.memory import MemoryStorage
from config import BOT_TOKEN
from handlers import start, upload, playlists, artist, metadata

logging.basicConfig(level=logging.INFO)

async def main():
    bot = Bot(token=BOT_TOKEN)
    storage = MemoryStorage()
    dp = Dispatcher(storage=storage)

    dp.include_router(metadata.router)
    dp.include_router(start.router)
    dp.include_router(upload.router)
    dp.include_router(playlists.router)
    dp.include_router(artist.router)

    print("üöÄ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω...")
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())


# ===== .\collect_code.py =====

Ôªøimport os

def collect_code(output_file="bot_code.txt"):
    with open(output_file, "w", encoding="utf-8") as out:
        for root, _, files in os.walk("."):
            for file in files:
                if file.endswith(".py"):
                    path = os.path.join(root, file)
                    out.write(f"\n\n# ===== {path} =====\n\n")
                    with open(path, "r", encoding="utf-8") as f:
                        out.write(f.read())
    print(f"‚úÖ –ö–æ–¥ –≤—Å–µ—Ö —Ñ–∞–π–ª–æ–≤ —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ {output_file}")

if __name__ == "__main__":
    collect_code()


# ===== .\config.py =====

# config.py
import os
from dotenv import load_dotenv

load_dotenv()

BOT_TOKEN = os.getenv("BOT_TOKEN")
STORAGE_CHAT_ID = int(os.getenv("STORAGE_CHAT_ID")) if os.getenv("STORAGE_CHAT_ID") else None
BOT_VERSION = os.getenv("BOT_VERSION", "v1.1")


# ===== .\database.py =====

Ôªø# database.py
import sqlite3

class Database:
    def __init__(self, path="database.db"):
        self.conn = sqlite3.connect(path, check_same_thread=False)
        self.cur = self.conn.cursor()
        self._create_tables()
        self._ensure_columns()

    def _create_tables(self):
        self.cur.execute('''
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                telegram_id INTEGER UNIQUE,
                name TEXT
            )
        ''')
        self.cur.execute('''
            CREATE TABLE IF NOT EXISTS artists (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                name TEXT
            )
        ''')
        self.cur.execute('''
            CREATE TABLE IF NOT EXISTS tracks (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                artist_id INTEGER,
                title TEXT,
                performer TEXT,
                file_id TEXT,
                storage_message_id INTEGER,
                is_common INTEGER DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        self.cur.execute('''
            CREATE TABLE IF NOT EXISTS notifications (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                message TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        self.conn.commit()

    def _ensure_columns(self):
        try:
            self.cur.execute("PRAGMA table_info(tracks)")
            cols = [r[1] for r in self.cur.fetchall()]
            if "artist_id" not in cols:
                try:
                    self.cur.execute("ALTER TABLE tracks ADD COLUMN artist_id INTEGER")
                except Exception:
                    pass
            if "storage_message_id" not in cols:
                try:
                    self.cur.execute("ALTER TABLE tracks ADD COLUMN storage_message_id INTEGER")
                except Exception:
                    pass
            self.conn.commit()
        except Exception:
            pass

    # users
    def add_user(self, telegram_id, name):
        self.cur.execute("INSERT OR IGNORE INTO users (telegram_id, name) VALUES (?, ?)", (telegram_id, name))
        self.conn.commit()

    def get_user(self, telegram_id):
        self.cur.execute("SELECT * FROM users WHERE telegram_id = ?", (telegram_id,))
        return self.cur.fetchone()

    def get_all_users(self):
        self.cur.execute("SELECT telegram_id FROM users")
        return [row[0] for row in self.cur.fetchall()]

    # artists
    def add_artist(self, user_id, name):
        self.cur.execute("INSERT INTO artists (user_id, name) VALUES (?, ?)", (user_id, name))
        self.conn.commit()
        return self.cur.lastrowid

    def get_all_artists(self):
        self.cur.execute("SELECT id, user_id, name FROM artists ORDER BY name ASC")
        return self.cur.fetchall()

    def get_artist(self, artist_id):
        self.cur.execute("SELECT id, user_id, name FROM artists WHERE id = ?", (artist_id,))
        return self.cur.fetchone()

    def get_user_artists(self, user_id):
        self.cur.execute("SELECT id, name FROM artists WHERE user_id = ?", (user_id,))
        return self.cur.fetchall()

    def delete_artist(self, artist_id, user_id):
        self.cur.execute("DELETE FROM artists WHERE id = ? AND user_id = ?", (artist_id, user_id))
        self.conn.commit()

    def get_or_create_first_artist(self, user_id, username_fallback):
        artists = self.get_user_artists(user_id)
        if artists:
            return artists[0][0], artists[0][1]
        name = (username_fallback or f"artist_{user_id}")[:128]
        aid = self.add_artist(user_id, name)
        return aid, name

    # tracks
    def add_user_track(self, user_id, file_id, title, performer, artist_id=None, storage_message_id=None):
        self.cur.execute("""
            INSERT INTO tracks (user_id, artist_id, title, performer, file_id, storage_message_id, is_common)
            VALUES (?, ?, ?, ?, ?, ?, 0)
        """, (user_id, artist_id, title, performer, file_id, storage_message_id))
        self.conn.commit()
        return self.cur.lastrowid

    def add_common_track(self, user_id, file_id, title, performer, artist_id=None, storage_message_id=None):
        self.cur.execute("""
            INSERT INTO tracks (user_id, artist_id, title, performer, file_id, storage_message_id, is_common)
            VALUES (?, ?, ?, ?, ?, ?, 1)
        """, (user_id, artist_id, title, performer, file_id, storage_message_id))
        self.conn.commit()
        return self.cur.lastrowid

    def get_user_tracks(self, user_id):
        self.cur.execute("SELECT * FROM tracks WHERE user_id = ? ORDER BY created_at DESC", (user_id,))
        return self.cur.fetchall()

    def get_common_tracks(self):
        self.cur.execute("SELECT * FROM tracks WHERE is_common = 1 ORDER BY created_at DESC")
        return self.cur.fetchall()

    def get_track(self, track_id):
        self.cur.execute("SELECT * FROM tracks WHERE id = ?", (track_id,))
        return self.cur.fetchone()

    def delete_track(self, track_id):
        self.cur.execute("DELETE FROM tracks WHERE id = ?", (track_id,))
        self.conn.commit()

    # notifications (utility)
    def add_notification(self, user_id, message):
        self.cur.execute("INSERT INTO notifications (user_id, message) VALUES (?, ?)", (user_id, message))
        self.conn.commit()


# ===== .\db_instance.py =====

# db_instance.py
from database import Database
db = Database()


# ===== .\keyboards.py =====

Ôªø# keyboards.py
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

def main_menu():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üéß –ú–æ–π –∫–∞—Ç–∞–ª–æ–≥", callback_data="my_catalog")],
        [InlineKeyboardButton(text="üåç –û–±—â–∏–π –ø–ª–µ–π–ª–∏—Å—Ç", callback_data="common_playlist")],
        [InlineKeyboardButton(text="üé§ –ú–æ–∏ –∫–∞—Ä—Ç–æ—á–∫–∏ –∞—Ä—Ç–∏—Å—Ç–∞", callback_data="my_artist")],
        [InlineKeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å —Ç—Ä–µ–∫", callback_data="add_track")],
        [InlineKeyboardButton(text="‚ÑπÔ∏è –û –±–æ—Ç–µ", callback_data="about_bot")]
    ])

def track_save_menu():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ", callback_data="edit_metadata")],
        [InlineKeyboardButton(text="üíæ –õ–∏—á–Ω—ã–π –∫–∞—Ç–∞–ª–æ–≥", callback_data="save_personal")],
        [InlineKeyboardButton(text="üåç –û–±—â–∏–π –ø–ª–µ–π–ª–∏—Å—Ç", callback_data="save_common")],
        [InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_upload")]
    ])


# ===== .\handlers\artist.py =====

Ôªø# handlers/artist.py
from aiogram import Router, F
from aiogram.types import CallbackQuery, Message, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext
from db_instance import db
from keyboards import main_menu

router = Router()

class ArtistForm(StatesGroup):
    waiting_for_name = State()

@router.callback_query(lambda c: c.data == "common_playlist")
async def common_playlist(callback: CallbackQuery):
    artists = db.get_all_artists()
    if not artists:
        return await callback.message.edit_text("üåç –í –æ–±—â–µ–º –ø–ª–µ–π–ª–∏—Å—Ç–µ –ø–æ–∫–∞ –Ω–µ—Ç –∞—Ä—Ç–∏—Å—Ç–æ–≤.", reply_markup=main_menu())

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=a[2], callback_data=f"artist_{a[0]}")] for a in artists
    ])
    keyboard.inline_keyboard.append([InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")])
    await callback.message.edit_text("üé§ –ê—Ä—Ç–∏—Å—Ç—ã:", reply_markup=keyboard)

@router.callback_query(lambda c: c.data.startswith("artist_"))
async def view_artist(callback: CallbackQuery):
    try:
        artist_id = int(callback.data.split("_", 1)[1])
    except Exception:
        await callback.answer("–ù–µ–≤–µ—Ä–Ω—ã–π –∞—Ä—Ç–∏—Å—Ç.", show_alert=True)
        return
    artist = db.get_artist(artist_id)
    if not artist:
        return await callback.message.answer("‚ö†Ô∏è –ê—Ä—Ç–∏—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.")

    tracks = db.cur.execute("SELECT id, title, performer FROM tracks WHERE artist_id = ? AND is_common = 1 ORDER BY created_at DESC", (artist[0],)).fetchall()
    text = f"üé§ *{artist[2]}*\n\nüéµ –¢—Ä–µ–∫–∏:"
    if not tracks:
        text += "\n(–£ –∞—Ä—Ç–∏—Å—Ç–∞ –ø–æ–∫–∞ –Ω–µ—Ç —Ç—Ä–µ–∫–æ–≤ –≤ –æ–±—â–µ–º –ø–ª–µ–π–ª–∏—Å—Ç–µ)"

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=f"{t[2]} ‚Äî {t[1]}", callback_data=f"play_{t[0]}")] for t in tracks
    ])
    keyboard.inline_keyboard.append([InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="common_playlist")])
    await callback.message.edit_text(text, parse_mode="Markdown", reply_markup=keyboard)

@router.callback_query(lambda c: c.data == "my_artist")
async def my_artist(callback: CallbackQuery):
    user_id = callback.from_user.id
    artists = db.get_user_artists(user_id)
    if not artists:
        kb = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="üÜï –°–æ–∑–¥–∞—Ç—å –∫–∞—Ä—Ç–æ—á–∫—É", callback_data="create_artist_card")],
            [InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")]
        ])
        return await callback.message.edit_text("üé§ –£ —Ç–µ–±—è –µ—â—ë –Ω–µ—Ç –∫–∞—Ä—Ç–æ—á–µ–∫ –∞—Ä—Ç–∏—Å—Ç–∞.", reply_markup=kb)

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=a[1], callback_data=f"artist_{a[0]}")] for a in artists
    ])
    kb.inline_keyboard.append([InlineKeyboardButton(text="‚ûï –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é", callback_data="create_artist_card")])
    kb.inline_keyboard.append([InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")])
    await callback.message.edit_text("üé§ –¢–≤–æ–∏ –∫–∞—Ä—Ç–æ—á–∫–∏ –∞—Ä—Ç–∏—Å—Ç–æ–≤:", reply_markup=kb)

@router.callback_query(lambda c: c.data == "create_artist_card")
async def start_artist_creation(callback: CallbackQuery, state: FSMContext):
    await callback.message.edit_text("–í–≤–µ–¥–∏—Ç–µ –∏–º—è –Ω–æ–≤–æ–≥–æ –∞—Ä—Ç–∏—Å—Ç–∞:")
    await state.set_state(ArtistForm.waiting_for_name)

@router.message(ArtistForm.waiting_for_name)
async def process_artist_name(message: Message, state: FSMContext):
    name = message.text.strip()
    if not name:
        await message.answer("–ò–º—è –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –í–≤–µ–¥–∏ –µ—â—ë —Ä–∞–∑:")
        return
    db.add_artist(message.from_user.id, name)
    await message.answer(f"‚úÖ –ö–∞—Ä—Ç–æ—á–∫–∞ –∞—Ä—Ç–∏—Å—Ç–∞ '{name}' —Å–æ–∑–¥–∞–Ω–∞!", reply_markup=main_menu())
    await state.clear()


# ===== .\handlers\metadata.py =====

Ôªø# handlers/metadata.py
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from keyboards import main_menu
from db_instance import db

router = Router()

class MetadataForm(StatesGroup):
    waiting_for_title = State()
    waiting_for_performer_choice = State()

# === –ù–∞—á–∞–ª–æ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö ===
@router.callback_query(F.data == "edit_metadata")
async def start_metadata_edit(callback: CallbackQuery, state: FSMContext):
    await callback.message.answer("üéµ –í–≤–µ–¥–∏ –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞:")
    await state.set_state(MetadataForm.waiting_for_title)


# === –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–≤–æ–¥–∏—Ç –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ ===
@router.message(MetadataForm.waiting_for_title)
async def set_new_title(message: Message, state: FSMContext):
    title = message.text.strip()
    if not title:
        await message.answer("‚ö†Ô∏è –ù–∞–∑–≤–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –í–≤–µ–¥–∏ –µ—â—ë —Ä–∞–∑:")
        return
    await state.update_data(title=title)

    user_id = message.from_user.id
    artists = db.get_user_artists(user_id)

    if not artists:
        kb = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="‚ûï –°–æ–∑–¥–∞—Ç—å –∫–∞—Ä—Ç–æ—á–∫—É", callback_data="create_artist_card")],
            [InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_metadata")]
        ])
        await message.answer("–£ —Ç–µ–±—è –Ω–µ—Ç –∫–∞—Ä—Ç–æ—á–µ–∫ –∞—Ä—Ç–∏—Å—Ç–∞. –°–æ–∑–¥–∞–π –Ω–æ–≤—É—é, —á—Ç–æ–±—ã —É–∫–∞–∑–∞—Ç—å –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è.", reply_markup=kb)
        await state.set_state(MetadataForm.waiting_for_performer_choice)
        return

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=a[1], callback_data=f"meta_artist_{a[0]}")] for a in artists
    ])
    kb.inline_keyboard.append([InlineKeyboardButton(text="‚ûï –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é", callback_data="create_artist_card")])
    kb.inline_keyboard.append([InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_metadata")])

    await message.answer("üé§ –í—ã–±–µ—Ä–∏ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è (—Ç–≤–æ—é –∫–∞—Ä—Ç–æ—á–∫—É –∞—Ä—Ç–∏—Å—Ç–∞):", reply_markup=kb)
    await state.set_state(MetadataForm.waiting_for_performer_choice)


# === –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ –∫–∞—Ä—Ç–æ—á–∫–∏ –∞—Ä—Ç–∏—Å—Ç–∞ ===
@router.callback_query(F.data.startswith("meta_artist_"))
async def set_metadata_artist(callback: CallbackQuery, state: FSMContext):
    try:
        artist_id = int(callback.data.split("_", 2)[2])
    except Exception:
        await callback.answer("–ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä.", show_alert=True)
        return

    artist = db.get_artist(artist_id)
    if not artist:
        await callback.answer("–ö–∞—Ä—Ç–æ—á–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.", show_alert=True)
        return

    await state.update_data(performer=artist[2])
    data = await state.get_data()
    title = data.get("title", "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è")
    performer = artist[2]

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚úÖ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å", callback_data="confirm_metadata")],
        [InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∏—Ç—å", callback_data="cancel_metadata")]
    ])

    await callback.message.edit_text(
        f"üìÄ *–ü—Ä–æ–≤–µ—Ä–∏–º:*\nüéµ –ù–∞–∑–≤–∞–Ω–∏–µ: {title}\nüë§ –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å: {performer}",
        reply_markup=kb,
        parse_mode="Markdown"
    )


# === –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö ===
@router.callback_query(F.data == "confirm_metadata")
async def confirm_metadata(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    title = data.get("title", "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è")
    performer = data.get("performer", "–ù–µ–∏–∑–≤–µ—Å—Ç–µ–Ω")

    await callback.message.edit_text(
        f"‚úÖ –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω—ã!\n\nüéµ –ù–∞–∑–≤–∞–Ω–∏–µ: {title}\nüë§ –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å: {performer}",
        reply_markup=main_menu()
    )
    await state.clear()


# === –û—Ç–º–µ–Ω–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è ===
@router.callback_query(F.data == "cancel_metadata")
async def cancel_metadata(callback: CallbackQuery, state: FSMContext):
    await callback.message.edit_text("‚ùå –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=main_menu())
    await state.clear()


# ===== .\handlers\playlists.py =====

Ôªø# handlers/playlists.py
from aiogram import Router
from aiogram.types import CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from db_instance import db
from keyboards import main_menu

router = Router()

@router.callback_query(lambda c: c.data == "my_catalog")
async def my_catalog(callback: CallbackQuery):
    user_id = callback.from_user.id
    tracks = db.get_user_tracks(user_id)
    if not tracks:
        return await callback.message.edit_text("üì≠ –í —Ç–≤–æ—ë–º –∫–∞—Ç–∞–ª–æ–≥–µ –ø–æ–∫–∞ –Ω–µ—Ç —Ç—Ä–µ–∫–æ–≤.", reply_markup=main_menu())

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=f"{t[4] or 'NoName'} ‚Äî {t[3] or 'NoArtist'}", callback_data=f"play_{t[0]}")] for t in tracks
    ])
    kb.inline_keyboard.append([InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")])
    await callback.message.edit_text("üéß –¢–≤–æ–∏ —Ç—Ä–µ–∫–∏:", reply_markup=kb)



# ===== .\handlers\start.py =====

Ôªø# handlers/start.py
from aiogram import Router, F, Bot
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.filters import Command
from keyboards import main_menu
from db_instance import db
from config import STORAGE_CHAT_ID


router = Router()

@router.message(Command("start"))
async def cmd_start(message: Message):
    db.add_user(message.from_user.id, message.from_user.full_name or message.from_user.first_name)
    await message.answer(
        f"üëã –ü—Ä–∏–≤–µ—Ç, {message.from_user.first_name}!\n–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ GarageLib.\n\nüì¶ –í–µ—Ä—Å–∏—è –±–æ—Ç–∞: *{db.get_user(message.from_user.id) and 'v1.1' or 'v1.1'}*",
        reply_markup=main_menu(),
        parse_mode="Markdown"
    )

@router.callback_query(F.data == "about_bot")
async def about_bot(callback: CallbackQuery):
    text = (
        "ü§ñ GarageLib Bot v1.2\n\n"
        "–ë–æ—Ç –¥–ª—è –∞—Ä—Ç–∏—Å—Ç–æ–≤: –∑–∞–≥—Ä—É–∂–∞–π –¥–µ–º–æ, —É–ø—Ä–∞–≤–ª—è–π –ª–∏—á–Ω—ã–º –∫–∞—Ç–∞–ª–æ–≥–æ–º –∏ –¥–µ–ª–∏—Å—å —Ç—Ä–µ–∫–∞–º–∏ –≤ –æ–±—â–µ–º –ø–ª–µ–π–ª–∏—Å—Ç–µ.\n\n"
        "–§—É–Ω–∫—Ü–∏–∏:\n‚Ä¢ –õ–∏—á–Ω—ã–π –∫–∞—Ç–∞–ª–æ–≥\n‚Ä¢ –û–±—â–∏–π –ø–ª–µ–π–ª–∏—Å—Ç —Å –∫–∞—Ä—Ç–æ—á–∫–∞–º–∏ –∞—Ä—Ç–∏—Å—Ç–æ–≤\n‚Ä¢ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Ç—Ä–µ–∫–∞ –≤ –æ–±—â–∏–π –ø–ª–µ–π–ª–∏—Å—Ç\n‚Ä¢ –£–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö\n"
    )
    try:
        await callback.message.edit_text(text, reply_markup=main_menu())
    except Exception:
        await callback.message.answer(text, reply_markup=main_menu())

@router.callback_query(F.data == "back_main")
async def back_main(callback: CallbackQuery):
    try:
        await callback.message.edit_text("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=main_menu())
    except Exception:
        await callback.message.answer("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=main_menu())

@router.callback_query(F.data.startswith("play_"))
async def play_track(callback: CallbackQuery):
    try:
        tid = int(callback.data.split("_", 1)[1])
    except Exception:
        await callback.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ç—Ä–µ–∫.", show_alert=True)
        return

    track = db.get_track(tid)
    if not track:
        await callback.answer("‚ö†Ô∏è –¢—Ä–µ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return

    title = track[3] or "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è"
    performer = track[4] or "–ù–µ–∏–∑–≤–µ—Å—Ç–µ–Ω"

    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üéß –ü–æ—Å–ª—É—à–∞—Ç—å", callback_data=f"listen_{tid}")],
        [InlineKeyboardButton(text="üóë –£–¥–∞–ª–∏—Ç—å", callback_data=f"delete_{tid}")],
        [InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_main")]
    ])

    text = f"üéµ {performer} ‚Äî {title}"
    try:
        await callback.message.edit_text(text, reply_markup=kb)
    except Exception:
        await callback.message.answer(text, reply_markup=kb)


@router.callback_query(F.data.startswith("listen_"))
async def listen_track(callback: CallbackQuery):
    try:
        tid = int(callback.data.split("_", 1)[1])
    except Exception:
        await callback.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ç—Ä–µ–∫.", show_alert=True)
        return

    track = db.get_track(tid)
    if not track:
        await callback.answer("‚ö†Ô∏è –¢—Ä–µ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return

    file_id = track[5]  # file_id –≤ –ë–î
    title = track[3] or "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è"
    performer = track[4] or "–ù–µ–∏–∑–≤–µ—Å—Ç–µ–Ω"
    try:
        await callback.message.answer_audio(audio=file_id, caption=f"{performer} ‚Äî {title}")
    except Exception:
        await callback.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç—Ä–µ–∫.", show_alert=True)


@router.callback_query(F.data.startswith("delete_"))
async def delete_track(callback: CallbackQuery, bot: Bot):
    try:
        tid = int(callback.data.split("_", 1)[1])
    except Exception:
        await callback.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ç—Ä–µ–∫.", show_alert=True)
        return

    track = db.get_track(tid)
    if not track:
        await callback.answer("‚ö†Ô∏è –¢—Ä–µ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return

    owner_id = track[1]  # user_id –≤–ª–∞–¥–µ–ª—å—Ü–∞
    if callback.from_user.id != owner_id:
        await callback.answer("üö´ –¢—ã –Ω–µ –º–æ–∂–µ—à—å —É–¥–∞–ª–∏—Ç—å —á—É–∂–æ–π —Ç—Ä–µ–∫.", show_alert=True)
        return

    # –ü–æ–ø—ã—Ç–∞—Ç—å—Å—è —É–¥–∞–ª–∏—Ç—å –∏–∑ –∫–∞–Ω–∞–ª–∞-—Ö—Ä–∞–Ω–∏–ª–∏—â–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å message_id)
    storage_msg_id = track[6]  # storage_message_id
    if storage_msg_id:
        try:
            await bot.delete_message(chat_id=STORAGE_CHAT_ID, message_id=storage_msg_id)
        except Exception:
            pass

    # –£–¥–∞–ª—è–µ–º –∑–∞–ø–∏—Å—å –∏–∑ –ë–î
    db.delete_track(tid)

    try:
        await callback.message.edit_text("üóë –¢—Ä–µ–∫ —É–¥–∞–ª—ë–Ω.", reply_markup=main_menu())
    except Exception:
        await callback.message.answer("üóë –¢—Ä–µ–∫ —É–¥–∞–ª—ë–Ω.", reply_markup=main_menu())


# ===== .\handlers\upload.py =====

Ôªøfrom aiogram import Router, F, Bot
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from keyboards import track_save_menu, main_menu
from config import STORAGE_CHAT_ID
from db_instance import db
import asyncio

router = Router()


class UploadForm(StatesGroup):
    waiting_for_audio = State()
    waiting_for_meta_edit = State()


async def safe_edit_or_answer(message_obj, text, reply_markup=None, parse_mode=None):
    """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–ª–∏ –æ—Ç–≤–µ—Ç (—á—Ç–æ–±—ã –Ω–µ –ø–∞–¥–∞–ª –ø—Ä–∏ –æ–¥–∏–Ω–∞–∫–æ–≤–æ–º —Ç–µ–∫—Å—Ç–µ)."""
    try:
        await message_obj.edit_text(text, reply_markup=reply_markup, parse_mode=parse_mode)
    except Exception:
        try:
            await message_obj.answer(text, reply_markup=reply_markup, parse_mode=parse_mode)
        except Exception:
            pass


# === –®–∞–≥ 1. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–∂–∞–ª ‚Äú–î–æ–±–∞–≤–∏—Ç—å —Ç—Ä–µ–∫‚Äù ===
@router.callback_query(F.data == "add_track")
async def add_track_menu(callback: CallbackQuery, state: FSMContext):
    db.add_user(callback.from_user.id, callback.from_user.full_name or callback.from_user.first_name)
    await callback.message.answer("üéµ –û—Ç–ø—Ä–∞–≤—å –º–Ω–µ –∞—É–¥–∏–æ—Ñ–∞–π–ª (mp3/ogg), —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å –µ–≥–æ.")
    await state.clear()
    await state.set_state(UploadForm.waiting_for_audio)


# === –®–∞–≥ 2. –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ç–ø—Ä–∞–≤–∏–ª –∞—É–¥–∏–æ—Ñ–∞–π–ª ===
@router.message(F.audio)
async def on_audio(message: Message, state: FSMContext):
    audio = message.audio
    user_id = message.from_user.id

    db.add_user(user_id, message.from_user.full_name or message.from_user.first_name)

    title = audio.title or "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è"
    performer = audio.performer or (message.from_user.full_name or message.from_user.first_name)

    await state.update_data(file_id=audio.file_id, title=title, performer=performer)
    await message.answer(
        f"üìÄ –¢—Ä–µ–∫: *{title}*\n–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å: *{performer}*\n\n–ö—É–¥–∞ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å?",
        reply_markup=track_save_menu(),
        parse_mode="Markdown"
    )
    await state.set_state(UploadForm.waiting_for_meta_edit)


# === –û—Ç–º–µ–Ω–∞ ===
@router.callback_query(F.data == "cancel_upload")
async def cancel_upload(callback: CallbackQuery, state: FSMContext):
    await state.clear()
    await safe_edit_or_answer(callback.message, "‚ùå –û—Ç–º–µ–Ω–µ–Ω–æ. –í–æ–∑–≤—Ä–∞—â–∞—é –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.", reply_markup=main_menu())


# === –®–∞–≥ 3. –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ç—Ä–µ–∫–∞ ===
@router.callback_query(F.data.in_(["save_personal", "save_common"]))
async def save_track(callback: CallbackQuery, state: FSMContext, bot: Bot):
    data = await state.get_data()
    file_id = data.get("file_id")
    title = data.get("title") or "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è"
    performer = data.get("performer") or (callback.from_user.full_name or callback.from_user.first_name)
    user_id = callback.from_user.id

    if not file_id:
        await safe_edit_or_answer(callback.message, "‚ö†Ô∏è –û—à–∏–±–∫–∞: —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Å–µ—Å—Å–∏–∏.", reply_markup=main_menu())
        await state.clear()
        return

    # === –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –ª–∏—á–Ω—ã–π –∫–∞—Ç–∞–ª–æ–≥ ===
    if callback.data == "save_personal":
        storage_msg_id = None
        saved_file_id = file_id
        try:
            sent = await bot.send_audio(chat_id=STORAGE_CHAT_ID, audio=file_id, caption=f"{performer} ‚Äî {title}")
            if hasattr(sent, "audio") and getattr(sent.audio, "file_id", None):
                saved_file_id = sent.audio.file_id
            storage_msg_id = sent.message_id
        except Exception as e:
            print(f"[storage send error personal] {e}")

        db.add_user_track(user_id=user_id, file_id=saved_file_id, title=title, performer=performer,
                          artist_id=None, storage_message_id=storage_msg_id)

        await safe_edit_or_answer(callback.message, f"‚úÖ –¢—Ä–µ–∫ ¬´{title}¬ª —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ –ª–∏—á–Ω–æ–º –∫–∞—Ç–∞–ª–æ–≥–µ.", reply_markup=main_menu())
        await state.clear()
        return

    # === –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –æ–±—â–∏–π –ø–ª–µ–π–ª–∏—Å—Ç ===
    user_artists = db.get_user_artists(user_id)
    if not user_artists:
        artist_id, artist_name = db.get_or_create_first_artist(user_id, performer)
        chosen_artist_id = artist_id
        chosen_artist_name = artist_name
    elif len(user_artists) == 1:
        chosen_artist_id = user_artists[0][0]
        chosen_artist_name = user_artists[0][1]
    else:
        kb = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text=a[1], callback_data=f"choose_artist_{a[0]}")] for a in user_artists
        ])
        kb.inline_keyboard.append([InlineKeyboardButton(text="‚ûï –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é", callback_data="create_artist_card")])
        kb.inline_keyboard.append([InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_upload")])
        await callback.message.answer("–£ —Ç–µ–±—è –Ω–µ—Å–∫–æ–ª—å–∫–æ –∫–∞—Ä—Ç–æ—á–µ–∫. –í—ã–±–µ—Ä–∏, –ø–æ–¥ –∫–∞–∫–æ–π –æ–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å —Ç—Ä–µ–∫:", reply_markup=kb)
        await state.update_data(pending_save="save_common")
        return

    storage_msg_id = None
    saved_file_id = file_id
    try:
        sent = await bot.send_audio(chat_id=STORAGE_CHAT_ID, audio=file_id, caption=f"{chosen_artist_name} ‚Äî {title}")
        if hasattr(sent, "audio") and getattr(sent.audio, "file_id", None):
            saved_file_id = sent.audio.file_id
        storage_msg_id = sent.message_id
    except Exception as e:
        print(f"[storage send error common] {e}")

    db.add_common_track(user_id=user_id, file_id=saved_file_id, title=title, performer=chosen_artist_name,
                        artist_id=chosen_artist_id, storage_message_id=storage_msg_id)

    # –†–∞—Å—Å—ã–ª–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
    users = db.get_all_users()
    note = f"üéµ {chosen_artist_name} –≤—ã–ª–æ–∂–∏–ª –Ω–æ–≤—ã–π —Ç—Ä–µ–∫: ¬´{title}¬ª"
    for uid in users:
        if uid == user_id:
            continue
        try:
            await bot.send_message(uid, note)
            await asyncio.sleep(0.03)
        except Exception:
            pass

    await safe_edit_or_answer(callback.message, f"üåç –¢—Ä–µ–∫ ¬´{title}¬ª –¥–æ–±–∞–≤–ª–µ–Ω –≤ –æ–±—â–∏–π –ø–ª–µ–π–ª–∏—Å—Ç –æ—Ç ¬´{chosen_artist_name}¬ª.",
                              reply_markup=main_menu())
    await state.clear()


# === –í—ã–±–æ—Ä –∞—Ä—Ç–∏—Å—Ç–∞ (–µ—Å–ª–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ—Å–∫–æ–ª—å–∫–æ –∫–∞—Ä—Ç–æ—á–µ–∫) ===
@router.callback_query(F.data.startswith("choose_artist_"))
async def choose_artist(callback: CallbackQuery, state: FSMContext, bot: Bot):
    try:
        artist_id = int(callback.data.split("_", 2)[2])
    except Exception:
        await callback.answer("–ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä.", show_alert=True)
        return

    data = await state.get_data()
    pending = data.get("pending_save")
    if pending != "save_common":
        await callback.answer("–ù–µ—Ç –æ–∂–∏–¥–∞–µ–º–æ–π –æ–ø–µ—Ä–∞—Ü–∏–∏.", show_alert=True)
        return

    file_id = data.get("file_id")
    title = data.get("title") or "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è"
    user_id = callback.from_user.id

    artist = db.get_artist(artist_id)
    if not artist:
        await callback.answer("–ö–∞—Ä—Ç–æ—á–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.", show_alert=True)
        await state.clear()
        return

    artist_name = artist[2]
    storage_msg_id = None
    saved_file_id = file_id
    try:
        sent = await bot.send_audio(chat_id=STORAGE_CHAT_ID, audio=file_id, caption=f"{artist_name} ‚Äî {title}")
        if hasattr(sent, "audio") and getattr(sent.audio, "file_id", None):
            saved_file_id = sent.audio.file_id
        storage_msg_id = sent.message_id
    except Exception as e:
        print(f"[storage send error choose_artist] {e}")

    db.add_common_track(user_id=user_id, file_id=saved_file_id, title=title, performer=artist_name,
                        artist_id=artist_id, storage_message_id=storage_msg_id)

    users = db.get_all_users()
    note = f"üéµ {artist_name} –≤—ã–ª–æ–∂–∏–ª –Ω–æ–≤—ã–π —Ç—Ä–µ–∫: ¬´{title}¬ª"
    for uid in users:
        if uid == user_id:
            continue
        try:
            await bot.send_message(uid, note)
            await asyncio.sleep(0.03)
        except Exception:
            pass

    await callback.message.answer(f"üåç –¢—Ä–µ–∫ ¬´{title}¬ª –¥–æ–±–∞–≤–ª–µ–Ω –≤ –æ–±—â–∏–π –ø–ª–µ–π–ª–∏—Å—Ç –æ—Ç ¬´{artist_name}¬ª.", reply_markup=main_menu())
    await state.clear()


# ===== .\handlers\__init__.py =====

# handlers/__init__.py
from . import start, upload, playlists, artist
